   # ReactJS instagram app

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

Courtesy tutorial: https://uregina-is.udemy.com/course-dashboard-redirect/?course_id=1471444

This application was initially built from this tutorial.
There are posts you can add with images, and then you can add comments on the post. The backend for the demonstration purposes is set to Firebase.
These posts, comments are stored on Firebase Realtime NoSQL database.
This project includes Redux, a complete workflow how to fetch (read), add (create), delete data from firebase backend and get instant update on the UI via 
Redux actions, store. 
#### Redux how it works:
With Redux, state manipulation is done centrally in reducer only, with naive approach, methods from a top level component are passed to bottom level via chain of props, then the bottom level components call method via passed props and modify the state, this can be messy if your application has a lot of components, especially they are nested, and you will loose track who modified which state, there could be race conditions. But with Redux, whenver a component wants to update state, they send a request by emitting an action, upon this request, reducer is the main file that responds and updates the state. reducer is the only file that updates the states centrally. Components can have access to the state, through injection but it is Ready only. For modifying a request via action needs to be sent. 
### Application flow
- To **initialize** the application with states/empty states, we create a reducer.js file. In that file for each of the state we need(ex: posts, comments) we create functions. Inside these methods we return the corresponding state. Ex: ```function posts(state=postList, action)```, now we can see that it takes argument of the initial state value, we can also pass empty. inside that we do some computation and return the state. this state is used everywhere in the app. the action parameter specifies if there is any action triggered, then modify the state and return the state. but initially it just returns the state as it is. Now to activate this states inside a centralized store, we create a centralized `store` in the `index.js` file. This will act as the central store.Now In order that the store is accessible to components, we wrap everything in the index.js with Provider tag, where we pass the store.
- **Giving access to state+actions to via injection:** Now in order to **have access** to state, and set of actions(to send request to update state), we need to **inject** these state+actions to a component, which can pass to nested components if necessary. Here we have injected these to the Main component. To *inject* this, we created a wrapper component `App.js`, then inside the App.js we use `connect` method, this App is then invoked inside the index as main component of the entire app. App acts as a wrapper and injects state+actions to the Main component. With `connect` method, we inject/pass the state and actions both to Main like this ```const App = withRouter( connect(mapStateToProps, mapDispathToProps)(Main))```. The parameters specify that the state+actions are now accessible inside the Main as a props as they are injected. as we know states are accessible, but they are ready only.
- **Pass down the injected powers(readonly state, actions) to other components**: From the Main app we see that we wanted to send the state+actions to photowall, add photo components, so they that they can use them, invoke them. we pass all props what we received directly as `{...this.props}`, however this is not receommended to send all props(which contain action, state) to everyone, here for simplicity we did this, we can send part of the props(some action or some state) to components.
- **Using the states, actions**: From the Main components we see that all injected props(states, actions) are passed to the `PhotoWall`, `AddPhoto` component. Now, we can see the `PhotoWall` app is grabbing the (state)posts from the props passed to it and showing it. The AddPhoto component, is grabbing the actions, and invoking them. This is because we gave state and actions to both of them. 
- **How to send actions**: so we have an actions.js file inside the redux file. Till now we understand that the action capabilities were passed into Main components as injection. Now Main and any other components who received the props from Main, will be able to call an action method. Each of the *action method who are called from Main/other components*, will have access to a method called `dispatch`, with this dispatch they can call another action methods inside the actions.js file. Eventually for each trigger, actions.js actions will return an object. This object is the action object. To identify what action happened, we put a type inside the object and other necessary data. This return will automatically invoke all the `reducers(for posts, for comments)` in the `reducer` file. but as we have tag, we should be able to distinguish for which entity it was.
- **Use the action triggers to update the state**: Now an action was triggered, say the type we sent was ADD_COMMENT, as with switch case inside the `reducer` we know what event that was, we will update the state acordingly or return the data we got from action as state. Eventually **what we will return** from the `reducer` **is the state of the application**, and change here means it will **trigger the corresponding UI components update**.

And this goes on, with the injected action powers, and action request to modify state is sent, reducer centrally modifies the state, returns the new state and this invokes UI changes. so the bottom level components dont change the state directly, the state change is delegated to reducers. 
